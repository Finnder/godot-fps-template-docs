{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Interactions Overview</li> </ul>"},{"location":"examples/","title":"Example Interactions","text":"<p>None yet!</p>"},{"location":"keymapper/","title":"Key Mapper","text":"<ul> <li>The key mapper is dead simple, and you should not need to modify the code in anyway. So I will tell you how to use it.</li> </ul>"},{"location":"keymapper/#how-to-use","title":"How To Use","text":"<ul> <li>What ever you add to the inputs in godot will automatically be reflected in the key mapper</li> </ul> <ul> <li>The <code>DEFAULT</code> keys are automatically mapped to whatever you initially set them to in the Input Map in Godot.</li> <li>Every keymapping is automatically saved when exiting and when modifying the inputs</li> </ul>"},{"location":"interaction/interaction-conditions/","title":"Interaction Conditions","text":"<ul> <li>Interaction conditions, only allow the interaction to trigger once its conditions are met.</li> <li>If you recall, the Interaction Node, checks all the conditions under the parent conditions node. Allowing the interaction to decide weather it should trigger the logics or not.</li> <li>You can build custom Interaction Conditions by extending the InteractionCondition class and overriding the <code>check()</code> function.</li> </ul>"},{"location":"interaction/interaction-conditions/#base-class","title":"Base Class","text":"<pre><code>extends Node\nclass_name InteractionCondition\n\nfunc check() -&gt; bool:\n    return true\n</code></pre>"},{"location":"interaction/interaction-conditions/#example-interaction-conditions","title":"Example Interaction Conditions","text":""},{"location":"interaction/interaction-conditions/#or-condition","title":"OR Condition","text":"<pre><code>extends InteractionCondition\n\n## If either of these interactions are triggered, this interaction will work\nclass_name InteractionConditionOr\n\n@export var interaction_trigger_check    : Interaction\n@export var interaction_trigger_check_02 : Interaction\n\nvar interaction_triggered    : bool  = false\nvar interaction_triggered_02 : bool  = false\n\nfunc _ready():\n    interaction_trigger_check.interaction_triggered.connect(func(): interaction_triggered = true)\n    interaction_trigger_check_02.interaction_triggered.connect(func(): interaction_triggered_02 = true)\n\nfunc check() -&gt; bool:\n    return check_keys() \n\nfunc check_keys():\n    return interaction_triggered or interaction_triggered_02\n</code></pre>"},{"location":"interaction/interaction-conditions/#and-condition","title":"AND Condition","text":"<pre><code>extends InteractionCondition\n\n## Checks if two interactions have been triggered, if not the interaction will not work\nclass_name InteractionConditionAnd\n\n@export var interaction_trigger_check    : Interaction\n@export var interaction_trigger_check_02 : Interaction\n\nvar interaction_triggered    : bool  = false\nvar interaction_triggered_02 : bool  = false\n\nfunc _ready():\n    interaction_trigger_check.interaction_triggered.connect(func(): interaction_triggered = true)\n    interaction_trigger_check_02.interaction_triggered.connect(func(): interaction_triggered_02 = true)\n\nfunc check() -&gt; bool:\n    return check_keys() \n\nfunc check_keys():\n    return interaction_triggered and interaction_triggered_02\n</code></pre>"},{"location":"interaction/interaction-conditions/#multi-conditon","title":"MULTI Conditon","text":"<ul> <li>Basically just AND, but with 1 or more interactions as a conditional <pre><code>extends InteractionCondition\nclass_name InteractionConditionMulti\n\n@export var interactions : Array[Interaction]\nvar interactions_mapping : Dictionary\n\nfunc _ready() -&gt; void:\n    setup()\n\nfunc setup():\n    for interaction in interactions:\n        interactions_mapping.set(interaction, false)\n        interaction.interaction_triggered.connect(func(): interactions_mapping.set(interaction, true))\n\nfunc check() -&gt; bool:\n    for i in interactions_mapping:\n        if interactions_mapping.get(i) == false: return false\n\n    return true\n</code></pre></li> </ul>"},{"location":"interaction/interaction-input-type/","title":"Interaction Input Type Node","text":"<ul> <li>The input type node will handle all user input related to the interaction.</li> <li>Like key presses, stepping into an area, looking at the interaction, etc.</li> </ul>"},{"location":"interaction/interaction-input-type/#how-to-use","title":"How to use","text":"<ol> <li>In the node menu simply search <code>InteractionInput</code> and you will see a few options pop up.</li> <li>The most common one you'll use is the <code>key press</code> input </li> </ol>"},{"location":"interaction/interaction-input-type/#input-types","title":"Input Types","text":""},{"location":"interaction/interaction-input-type/#area-interaction-input","title":"Area Interaction Input","text":"<ul> <li>Takes an <code>Area3D</code> as an argument, this will represent the area the player needs to step into to trigger the interaction</li> <li>You can make it trigger on enter or exit of the area</li> <li>Also an optional <code>Only Player Can Trigger</code> conditional, if you want other entities to trigger this interaction just uncheck it</li> </ul>"},{"location":"interaction/interaction-logics/","title":"Interaction Logics","text":"<ul> <li>The reason these exists is so we can maximize code reusability, and reduce code dependencies</li> <li> <p>It allows us to plug and play, rather then having to dig through code all day</p> </li> <li> <p>You can build custom Interaction Logics by extending the <code>InteractionLogic</code> class and overriding the <code>trigger()</code> function</p> </li> </ul>"},{"location":"interaction/interaction-logics/#base-class","title":"Base Class","text":"<pre><code>extends Node\nclass_name InteractionLogic\n\n## Triggers logic of this InteractionLogic\nfunc trigger():\n    pass\n</code></pre> <ul> <li>Here is the base class of this interaction logic</li> <li>trigger() will be on every interaction logic node, this is how you call the specific interaction logic.</li> <li>But if you recall, back to the Interaction Node, the interaction node has an <code>on_interact()</code> function, that calls all InteractionLogic nodes under the InteractionLogicParent.<ul> <li>That way we can have a simpler system, that just calls multiple logics, rather than just one.</li> </ul> </li> </ul>"},{"location":"interaction/interaction-logics/#interaction-logic-example-nodes","title":"Interaction Logic Example Nodes","text":""},{"location":"interaction/interaction-logics/#basic-interaction-logic-nodes","title":"Basic Interaction Logic Nodes","text":""},{"location":"interaction/interaction-logics/#interactionlogicdestroynode","title":"InteractionLogicDestroyNode","text":"<pre><code>extends InteractionLogic\nclass_name InteractionLogicDestroyNode\n\n@export var node_to_destroy : Node = null\n\nfunc trigger():\n    node_to_destroy.queue_free()\n</code></pre>"},{"location":"interaction/interaction-logics/#interactionlogicplayanimation","title":"InteractionLogicPlayAnimation","text":"<pre><code>extends InteractionLogic\nclass_name InteractionLogicPlayAnimation\n\nsignal logic_animation_finished\n@export var animation_player : AnimationPlayer\n@export var animation_name   : StringName\n\nfunc trigger():\n    if animation_player and animation_name:\n        animation_player.play(animation_name)\n        animation_player.animation_finished.connect(func(anim_name): \n            logic_animation_finished.emit()\n        )\n</code></pre>"},{"location":"interaction/interaction-logics/#interactionlogicdebug","title":"InteractionLogicDebug","text":"<pre><code>extends InteractionLogic\nclass_name InteractionLogicDebug\n\n@export var interaction_body : Node3D\n\nfunc trigger():\n    super.trigger()\n    if interaction_body:\n        Console.print_info(str(interaction_body.name + \"-&gt; INTERACTION TRIGGERED\"), true)\n</code></pre>"},{"location":"interaction/interaction-logics/#remote-trigger-interaction-logic-nodes","title":"REMOTE Trigger Interaction Logic Nodes","text":"<ul> <li>These nodes specialize in triggering other interactions, either by id, or node reference remotely. You can create chains of interactions.</li> <li>EX: A Interaction -&gt; B Interaction -&gt; C Interaction</li> </ul>"},{"location":"interaction/interaction-logics/#interactionlogictriggerbyrefs","title":"InteractionLogicTriggerByRefs","text":"<pre><code>extends InteractionLogic\n\n## Reference interaction node(s) to be triggered by this interaction\nclass_name InteractionLogicTriggerByRefs\n\n@export var interactions : Array[Interaction]\n\nfunc trigger() -&gt; void:\n    for interaction in interactions:\n        interaction.on_interact()\n</code></pre>"},{"location":"interaction/interaction-logics/#interactionlogictriggerbyids","title":"InteractionLogicTriggerByIds","text":"<pre><code>extends InteractionLogic\nclass_name InteractionLogicTriggerByIds\n\n@export var signal_string_id : Array[StringName]\n\nvar interactions : Array[Interaction]\n\nfunc trigger():\n    for interaction in interactions:\n        interaction.on_interact()\n\nfunc _ready() -&gt; void:\n    for i in signal_string_id:\n        var nodes_with_id = find_interactions_nodes_with_id(i)\n        interactions.append_array(nodes_with_id)\n\n## INFO: Helper Functions\nfunc find_interactions_nodes_with_id(string_id : StringName) -&gt; Array[Node]:\n    var result: Array[Node] = []\n\n    for node in get_all_nodes(get_tree().root):\n        for child in node.get_children():\n            if child is Interaction:\n                if child.interaction_id == string_id:\n                    result.append(child)\n\n    return result\n\nfunc get_all_nodes(root: Node) -&gt; Array[Node]:\n    var all_nodes: Array[Node] = []\n    var stack: Array[Node] = [root]\n\n    while stack.size() &gt; 0:\n        var current = stack.pop_back()\n        all_nodes.append(current)\n\n        for child in current.get_children():\n            stack.append(child)\n\n    return all_nodes\n</code></pre>"},{"location":"interaction/interactions/","title":"Interactions Overview","text":""},{"location":"interaction/interactions/#interaction-example","title":"Interaction Example","text":"<ul> <li> <p><code>InteractionInputs</code></p> <ul> <li>Contains all the ways the interaction can be triggered by the player</li> <li>In this case the most basic input is attached, <code>KeyPressInteractionInput</code> which does as its named. It just triggers off of a key press.<ul> <li>Every input key interaction input is defaulted to the <code>INTERACTION</code> keymapping. You can see this in the Godot Input Map.</li> <li>The player can change this in the keymapper when playing as well, you can change the default mapping to whatever as well.</li> </ul> </li> <li>You can add 0 or more interaction inputs to trigger the interaction.</li> </ul> </li> <li> <p><code>InteractionLogics</code></p> <ul> <li>I call the functionality and programming of the interaction <code>InteractionLogics</code> this is the thing that makes things do other things (that sounds like baby talk but thats the best way i can explain it right now lol)</li> <li>After all the conditions are consididered passed and interaction is triggered by a remote call or input then the logics run. There is also an option for a interaction failed logic.</li> <li>Logics are the bread and butter for the interactions, I give you a small tool box of the most needed logics but this is for you to expand as you develop your game. You will most likely need more customized and complex logic nodes for your game. You can find the default logic nodes built in HERE</li> </ul> </li> </ul>"},{"location":"interaction/interactions/#how-it-works","title":"How it works","text":""},{"location":"interaction/interactions/#interaction-node","title":"Interaction Node","text":"<ol> <li> <p><code>Interaction ID</code></p> <ul> <li>This allows us to remotely call the interaction if need be</li> <li>You can do this via the Jitspo in-game debug console using the <code>~</code> key, then typing <code>trigger-id &lt;INTERACTION ID&gt;</code>. </li> </ul> </li> <li> <p><code>Set Interaction Layers</code></p> <ul> <li>Sets the static objects layers so that the player can interact with the interaction. This must be active for the interaction to be triggered by the player.</li> <li>It does not need to be active, if you intend this interaction to not be triggered by the player, in the traditional sense. This is more for remote calls.</li> <li>The <code>DEFAULT INTERACTION LAYER</code> is defaulted to <code>3</code> and can be changed within the code. In the <code>interaction.gd</code> script, you can change it.</li> </ul> </li> <li><code>Mesh To Outline</code><ul> <li>This will add an outline to the object when interactable. This is still being worked on to be more flexable. But good for simple 3D objects. Not tested enough.</li> </ul> </li> </ol>"}]}
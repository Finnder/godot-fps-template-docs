{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"examples/","title":"Example Interactions","text":""},{"location":"examples/#door-interaction","title":"Door Interaction","text":"<ul> <li>You can see as the interaction ID I set it as <code>DOOR_01</code></li> <li>This is because I want to trigger the door logic, from an external node that will trigger based on an id, in this case <code>DOOR_01</code></li> </ul> <ul> <li>We want our logic to open the door, so I connected it to the animation player, and referenced the name of the animation I want to play called <code>open</code></li> </ul> <ul> <li>Now we can trigger the door, from an EXTERNAL interaction, like a button or just by using the base interaction prefab.</li> <li>And we add the InteractionLogicTriggerByIds Node because we want to trigger the door interaction  by the id of <code>DOOR_01</code></li> <li>Notice we can also trigger multiple Interactions!</li> </ul>"},{"location":"keymapper/","title":"Key Mapper","text":"<ul> <li>The key mapper is dead simple, and you should not need to modify the code in anyway. So I will tell you how to use it.</li> </ul>"},{"location":"keymapper/#how-to-use","title":"How To Use","text":"<ul> <li>What ever you add to the inputs in godot will automatically be reflected in the key mapper</li> </ul> <ul> <li>The <code>DEFAULT</code> keys are automatically mapped to whatever you initially set them to in the Input Map in Godot.</li> <li>Every keymapping is automatically saved when exiting and when modifying the inputs</li> </ul>"},{"location":"interaction/interaction-conditions/","title":"Interaction Conditions","text":"<ul> <li>Interaction conditions, only allow the interaction to trigger once its conditions are met.</li> <li>If you recall, the Interaction Node, checks all the conditions under the parent conditions node. Allowing the interaction to decide weather it should trigger the logics or not.</li> </ul>"},{"location":"interaction/interaction-conditions/#base-class","title":"Base Class","text":"<pre><code>extends Node\nclass_name InteractionCondition\n\nfunc check() -&gt; bool:\n    return true\n</code></pre>"},{"location":"interaction/interaction-conditions/#example-interaction-conditions","title":"Example Interaction Conditions","text":""},{"location":"interaction/interaction-conditions/#or-condition","title":"OR Condition","text":"<pre><code>extends InteractionCondition\n\n## If either of these interactions are triggered, this interaction will work\nclass_name InteractionConditionOr\n\n@export var interaction_trigger_check    : Interaction\n@export var interaction_trigger_check_02 : Interaction\n\nvar interaction_triggered    : bool  = false\nvar interaction_triggered_02 : bool  = false\n\nfunc _ready():\n    interaction_trigger_check.interaction_triggered.connect(func(): interaction_triggered = true)\n    interaction_trigger_check_02.interaction_triggered.connect(func(): interaction_triggered_02 = true)\n\nfunc check() -&gt; bool:\n    return check_keys() \n\nfunc check_keys():\n    return interaction_triggered or interaction_triggered_02\n</code></pre>"},{"location":"interaction/interaction-conditions/#and-condition","title":"AND Condition","text":"<pre><code>extends InteractionCondition\n\n## Checks if two interactions have been triggerd, if not the interaction will not work\nclass_name InteractionConditionAnd\n\n@export var interaction_trigger_check    : Interaction\n@export var interaction_trigger_check_02 : Interaction\n\nvar interaction_triggered    : bool  = false\nvar interaction_triggered_02 : bool  = false\n\nfunc _ready():\n    interaction_trigger_check.interaction_triggered.connect(func(): interaction_triggered = true)\n    interaction_trigger_check_02.interaction_triggered.connect(func(): interaction_triggered_02 = true)\n\nfunc check() -&gt; bool:\n    return check_keys() \n\nfunc check_keys():\n    return interaction_triggered and interaction_triggered_02\n</code></pre>"},{"location":"interaction/interaction-conditions/#multi-conditon","title":"MULTI Conditon","text":"<ul> <li>Basically just AND, but with more than 1 or more interactions as a conditional <pre><code>extends InteractionCondition\nclass_name InteractionConditionMulti\n\n@export var interactions : Array[Interaction]\nvar interactions_mapping : Dictionary\n\nfunc _ready() -&gt; void:\n    setup()\n\nfunc setup():\n    for interaction in interactions:\n        interactions_mapping.set(interaction, false)\n        interaction.interaction_triggered.connect(func(): interactions_mapping.set(interaction, true))\n\nfunc check() -&gt; bool:\n    for i in interactions_mapping:\n        if interactions_mapping.get(i) == false: return false\n\n    return true\n</code></pre></li> </ul>"},{"location":"interaction/interaction-input-type/","title":"Interaction Input Type Node","text":"<ul> <li>The input type node will handle all user input relating to the interaction.</li> </ul>"},{"location":"interaction/interaction-input-type/#features","title":"Features","text":"<ul> <li>You can also change the key that you use to interact to trigger the interaction, by default in the project the keys are F and Left-Click</li> <li>Supports hold interactions, meaning hold key for x amount of time, until the player triggers the Interaction.</li> <li>Supports area interactions, meaning you can assign an area 3d node, so you can trigger based on if and entity or player enters or exits the area.</li> </ul>"},{"location":"interaction/interaction-logics/","title":"Interaction Logics","text":"<ul> <li>There is endless possabilities with interaction logic nodes, this is where most of your code will go when creating custom logic interactions.</li> <li>The reason these exists is so we can maximize code reusability, and reduce code dependencies.</li> <li>It allows us to plug and play, rather then having to dig through code all day.</li> </ul>"},{"location":"interaction/interaction-logics/#base-class","title":"Base Class","text":"<pre><code>extends Node\nclass_name InteractionLogic\n\n## Triggers logic of this InteractionLogic\nfunc trigger():\n    pass\n</code></pre> <ul> <li>Here is the base class of this interaction logic</li> <li>trigger() will be on every interaction logic node, this is how you call the specific interaction logic.</li> <li>But if you recall, back to the Interaction Node, the interaction node has an <code>on_interact()</code> function, that calls all InteractionLogic nodes under the InteractionLogicParent.<ul> <li>That way we can have a simpler system, that just calls multiple logics, rather than just one.</li> </ul> </li> </ul>"},{"location":"interaction/interaction-logics/#interaction-logic-example-nodes","title":"Interaction Logic Example Nodes","text":""},{"location":"interaction/interaction-logics/#basic-interaction-logic-nodes","title":"Basic Interaction Logic Nodes","text":""},{"location":"interaction/interaction-logics/#interactionlogicdestroynode","title":"InteractionLogicDestroyNode","text":"<pre><code>extends InteractionLogic\nclass_name InteractionLogicDestroyNode\n\n@export var node_to_destroy : Node = null\n\nfunc trigger():\n    node_to_destroy.queue_free()\n</code></pre>"},{"location":"interaction/interaction-logics/#interactionlogicplayanimation","title":"InteractionLogicPlayAnimation","text":"<pre><code>extends InteractionLogic\nclass_name InteractionLogicPlayAnimation\n\nsignal logic_animation_finished\n@export var animation_player : AnimationPlayer\n@export var animation_name   : StringName\n\nfunc trigger():\n    if animation_player and animation_name:\n        animation_player.play(animation_name)\n        animation_player.animation_finished.connect(func(anim_name): \n            logic_animation_finished.emit()\n        )\n</code></pre>"},{"location":"interaction/interaction-logics/#interactionlogicdebug","title":"InteractionLogicDebug","text":"<pre><code>extends InteractionLogic\nclass_name InteractionLogicDebug\n\n@export var interaction_body : Node3D\n\nfunc trigger():\n    super.trigger()\n    if interaction_body:\n        Console.print_info(str(interaction_body.name + \"-&gt; INTERACTION TRIGGERED\"), true)\n</code></pre>"},{"location":"interaction/interaction-logics/#trigger-interaction-logic-nodes","title":"Trigger Interaction Logic Nodes","text":"<ul> <li>These nodes specialize in triggering other interactions, either by id, or node reference.</li> </ul>"},{"location":"interaction/interaction-logics/#interactionlogictriggerbyrefs","title":"InteractionLogicTriggerByRefs","text":"<pre><code>extends InteractionLogic\n\n## Reference interaction node(s) to be triggered by this interaction\nclass_name InteractionLogicTriggerByRefs\n\n@export var interactions : Array[Interaction]\n\nfunc trigger() -&gt; void:\n    for interaction in interactions:\n        interaction.on_interact()\n</code></pre>"},{"location":"interaction/interaction-logics/#interactionlogictriggerbyids","title":"InteractionLogicTriggerByIds","text":"<pre><code>extends InteractionLogic\nclass_name InteractionLogicTriggerByIds\n\n@export var signal_string_id : Array[StringName]\n\nvar interactions : Array[Interaction]\n\nfunc trigger():\n    for interaction in interactions:\n        interaction.on_interact()\n\nfunc _ready() -&gt; void:\n    for i in signal_string_id:\n        var nodes_with_id = find_interactions_nodes_with_id(i)\n        interactions.append_array(nodes_with_id)\n\n## INFO: Helper Functions\nfunc find_interactions_nodes_with_id(string_id : StringName) -&gt; Array[Node]:\n    var result: Array[Node] = []\n\n    for node in get_all_nodes(get_tree().root):\n        for child in node.get_children():\n            if child is Interaction:\n                if child.interaction_id == string_id:\n                    result.append(child)\n\n    return result\n\nfunc get_all_nodes(root: Node) -&gt; Array[Node]:\n    var all_nodes: Array[Node] = []\n    var stack: Array[Node] = [root]\n\n    while stack.size() &gt; 0:\n        var current = stack.pop_back()\n        all_nodes.append(current)\n\n        for child in current.get_children():\n            stack.append(child)\n\n    return all_nodes\n</code></pre>"},{"location":"interaction/interactions/","title":"Interactions Overview","text":""},{"location":"interaction/interactions/#the-interaction-system","title":"The Interaction System","text":""},{"location":"interaction/interactions/#interaction-overview","title":"Interaction Overview","text":"<ul> <li>Every interaction has a collection of interaction nodes, and different parts pieces.</li> <li>Its important to note that this system is built to be dynamic so you can even put interaction nodes, under any node to active it in some sort of way.<ul> <li>A good example of this is in the player node under the camera, there is a Interaction that simply shakes the camera.</li> </ul> </li> </ul>"},{"location":"interaction/interactions/#how-it-works","title":"How it works","text":""},{"location":"interaction/interactions/#interaction-node","title":"Interaction Node","text":"<ul> <li>This nodes references a few other nodes<ol> <li>Parent conditions node<ul> <li>Controls weither or not, the interaction can be triggered</li> <li>Every node that extends InteractionCondition class will be checked.</li> <li>If every condition check is passed, the interaction can be triggered by external sources.</li> </ul> </li> <li>Parent logic node<ul> <li>All nodes that extend InteractionLogic class, and are a child of this node will be triggered.</li> </ul> </li> <li>InteractionInputType Node<ul> <li>Handles all of the player interaction with the node. You can just remove this node, if you do not need player interaction.</li> </ul> </li> </ol> </li> </ul>"}]}